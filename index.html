<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>smooth_feedback: smooth_feedback: Control and estimation on Lie groups</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">smooth_feedback
   </div>
   <div id="projectbrief">Control and estimation on Lie groups</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">smooth_feedback: Control and estimation on Lie groups </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <a href="https://github.com/pettni/smooth_feedback/actions/workflows/build_and_test.yml"><img src="https://img.shields.io/github/workflow/status/pettni/smooth_feedback/build_and_test/master?style=flat-square" alt="CI Build and Test" class="inline"/></a> <a href="https://codecov.io/gh/pettni/smooth_feedback"><img src="https://img.shields.io/codecov/c/gh/pettni/smooth_feedback/master?style=flat-square" alt="Code coverage" class="inline"/></a> <a href="https://github.com/pettni/smooth_feedback/blob/master/LICENSE"><img src="https://img.shields.io/github/license/pettni/smooth_feedback.svg?style=flat-square" alt="License" style="pointer-events: none;" class="inline"/></a></p>
<p><img src="media/se2_example.gif" alt="" width="100%" class="inline"/></p>
<p>Tool collection for control and estimation on Lie groups leveraging the <a href="https://github.com/pettni/smooth/">smooth</a> library.</p>
<ul>
<li>Requirements: C++20, Eigen 3.4, boost::numeric::odeint, <a href="https://github.com/pettni/smooth/">smooth</a></li>
<li><a href="https://pettni.github.io/smooth_feedback">Documentation</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Control on Lie groups</h1>
<p>These controllers are implemented for systems with dynamics on the form <img src="https://latex.codecogs.com/png.image?\dpi{110}&space;\mathrm{d}^r&space;\mathbf{x}_t&space;=&space;f(t,&space;\mathbf{x},&space;\mathbf{u}),&space;\quad&space;t&space;\in&space;\mathbb{T},\mathbf{x}&space;\in&space;\mathbb{X},&space;\mathbf{u}&space;\in&space;\mathbb{U}" alt="" class="inline"/> where <code>T</code> is a <code>smooth::feedback::Time</code>, <code>X</code> is a <code>smooth::LieGroup</code>, and <code>U</code> is a <code>smooth::Manifold</code>.</p>
<p>Nonlinearities are handled via linearization around a reference point or trajectory. For group-linear dynamics this automatically results in a linear system in the tangent space, in which case these algorithms are expected to work very well. Linearization is done via <a href="https://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>. For this to work with the most performant methods (e.g. <a href="https://github.com/autodiff/autodiff/">autodiff</a>) the functions must be templated on the scalar type. The dynamical system</p>
<p><img src="https://latex.codecogs.com/png.latex?%5CSigma%20%3A%20%5Cleft%5C%7B%20%5Cbegin%7Baligned%7D%20%5Cmathrm%7Bd%7D%5Er%20%5Cmathbf%7Bx%7D_t%20%26%3D%20v%28t%29%2C%20%5Cquad%20%5Cmathbf%7Bx%7D%28t%29%20%5Cin%20%5Cmathbb%7BSE%7D%282%29%2C%20v%20%5Cin%20%5Cmathbb%7BR%7D%5E3%20%5C%5C%20%5Cfrac%7B%5Cmathrm%7Bd%7D%7D%7B%5Cmathrm%7Bd%7Dt%7D%20v%28t%29%20%26%3D%20A%20v%20&plus;%20B%20u%2C%20%5Cquad%20u%20%5Cin%20%5Cmathbb%7BR%7D%5E2%20%5Cend%7Baligned%7D%20%5Cright." alt="" class="inline"/></p>
<p>can be defined via a lambda function that supports automatic differentiation as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;smooth/bundle.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;smooth/se2.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> T = std::chrono::duration&lt;double&gt;;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line"><span class="keyword">using</span> X = smooth::Bundle&lt;smooth::SE2&lt;S&gt;, Eigen::Matrix&lt;S, 3, 1&gt;&gt;;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line"><span class="keyword">using</span> U = Eigen::Matrix&lt;S, 2, 1&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> Eigen::Matrix3d A{</div>
<div class="line">  {-0.2, 0, 0},</div>
<div class="line">  {0, 0, 0},</div>
<div class="line">  {0, 0, -0.4},</div>
<div class="line">};</div>
<div class="line"><span class="keyword">const</span> Eigen::Matrix&lt;double, 3, 2&gt; B{</div>
<div class="line">  {1, 0},</div>
<div class="line">  {0, 0},</div>
<div class="line">  {0, 1},</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> Sigma = []&lt;<span class="keyword">typename</span> S&gt;(T, <span class="keyword">const</span> X&lt;S&gt; &amp; x, <span class="keyword">const</span> U&lt;S&gt; &amp; u) -&gt; smooth::Tangent&lt;X&lt;S&gt;&gt; {</div>
<div class="line">  smooth::Tangent&lt;X&lt;S&gt;&gt; dx_dt;</div>
<div class="line">  dx_dt.head(3) = x.template part&lt;1&gt;();</div>
<div class="line">  dx_dt.tail(3) = A * x.template part&lt;1&gt;() + B * u;</div>
<div class="line">  <span class="keywordflow">return</span> dx_dt;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2"></a>
PID Control</h2>
<ul>
<li>Model-free</li>
<li>Assumes that inputs control body acceleration. See <code>examples/pid_se2.cpp</code> for an example of allocating PID inputs to actuators.</li>
</ul>
<p><b>Example</b> PID controller on SE(2)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;smooth/feedpack/pid.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classsmooth_1_1feedback_1_1PID.html">smooth::feedback::PID&lt;T, smooth::SE2d&gt;</a> pid;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set desired motion</span></div>
<div class="line">pid.<a class="code" href="classsmooth_1_1feedback_1_1PID.html#a26592d43e8511f07fa4a5d64a744b426">set_xdes</a>([](T T) -&gt; std::tuple&lt;smooth::SE2d, Eigen::Vector3d, Eigen::Vector3d&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> {</div>
<div class="line">    smooth::SE2d::Identity(),  <span class="comment">// position</span></div>
<div class="line">    Eigen::Vector3d::Zero(),   <span class="comment">// velocity (right derivative of position w.r.t. t)</span></div>
<div class="line">    Eigen::Vector3d::Zero(),   <span class="comment">// acceleration (second right derivative of position w.r.t. t)</span></div>
<div class="line">  };</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">T t               = T(1);                       <span class="comment">// current time</span></div>
<div class="line">smooth::SE2d x    = smooth::SE2d::Random();     <span class="comment">// current state</span></div>
<div class="line">Eigen::Vector3d v = Eigen::Vector3d::Random();  <span class="comment">// current body velocity</span></div>
<div class="line"> </div>
<div class="line">Eigen::Vector3d u = pid(t, x, v);</div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1PID_html"><div class="ttname"><a href="classsmooth_1_1feedback_1_1PID.html">smooth::feedback::PID</a></div><div class="ttdoc">Proportional-Integral-Derivative controller for Lie groups.</div><div class="ttdef"><b>Definition:</b> <a href="pid_8hpp_source.html#l00062">pid.hpp:63</a></div></div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1PID_html_a26592d43e8511f07fa4a5d64a744b426"><div class="ttname"><a href="classsmooth_1_1feedback_1_1PID.html#a26592d43e8511f07fa4a5d64a744b426">smooth::feedback::PID::set_xdes</a></div><div class="ttdeci">void set_xdes(T t0, const smooth::Curve&lt; G &gt; &amp;c)</div><div class="ttdoc">Set desired trajectory as a smooth::Curve.</div><div class="ttdef"><b>Definition:</b> <a href="pid_8hpp_source.html#l00165">pid.hpp:165</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3"></a>
Model-Predictive Control</h2>
<ul>
<li>Automatic linearization and time discretization of nonlinear continuous dynamics</li>
<li>Define state and input reference trajectories via arbitrary functions <code>T -&gt; X</code> and <code>T -&gt; U</code> for a time type T. The bus in the video above uses MPC to track the boundary of the circle.</li>
</ul>
<p><b>Example</b>: Model-predictive control for the system <code>Sigma</code> (see also <code>examples/mpc_asif_vehicle.cpp</code>)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;smooth/feedback/mpc.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classsmooth_1_1feedback_1_1MPC.html">smooth::feedback::MPC&lt;T, X&lt;double&gt;</a>, U&lt;double&gt;, decltype(Sigma)&gt; mpc(Sigma, {.T = 5, .K = 50});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set desired input and state trajectories</span></div>
<div class="line">mpc.<a class="code" href="classsmooth_1_1feedback_1_1MPC.html#ad06de7436df1739680bb0afa044e5b37">set_udes</a>([]&lt;<span class="keyword">typename</span> S&gt;(S t) -&gt; U&lt;S&gt; { <span class="keywordflow">return</span> U&lt;S&gt;::Zero(); });</div>
<div class="line">mpc.set_xdes([]&lt;<span class="keyword">typename</span> S&gt;(S t) -&gt; X&lt;S&gt; { <span class="keywordflow">return</span> X&lt;S&gt;::Identity(); });</div>
<div class="line"> </div>
<div class="line">T t(0);</div>
<div class="line">X&lt;double&gt; x = X&lt;double&gt;::Identity();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// get control input for time t and state x</span></div>
<div class="line"><span class="keyword">auto</span> [u, code] = mpc(t, x);</div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1MPC_html"><div class="ttname"><a href="classsmooth_1_1feedback_1_1MPC.html">smooth::feedback::MPC</a></div><div class="ttdoc">Model-Predictive Control (MPC) on Lie groups.</div><div class="ttdef"><b>Definition:</b> <a href="mpc_8hpp_source.html#l00120">mpc.hpp:121</a></div></div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1MPC_html_ad06de7436df1739680bb0afa044e5b37"><div class="ttname"><a href="classsmooth_1_1feedback_1_1MPC.html#ad06de7436df1739680bb0afa044e5b37">smooth::feedback::MPC::set_udes</a></div><div class="ttdeci">void set_udes(std::function&lt; U(T)&gt; &amp;&amp;u_des)</div><div class="ttdoc">Set the desired input trajectory (absolute time)</div><div class="ttdef"><b>Definition:</b> <a href="mpc_8hpp_source.html#l00265">mpc.hpp:265</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Active Set Invariance Filtering (ASIF)</h2>
<ul>
<li>Minimally invasive filtering of a control input in order to enforce state constraints. The bus in the video above is using an ASIF that avoids the red cylinder.</li>
<li>Automatic differentiation of nonlinear continuous dynamics and constraints</li>
<li>Theory (non-Lie group case) is described in e.g. <a href="https://thesis.library.caltech.edu/13771/1/My_Thesis.pdf">Thomas Gurriet's Ph.D. thesis</a></li>
</ul>
<p><b>Example</b>: Safety filtering for the system <code>Sigma</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;smooth/feedback/asif.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classsmooth_1_1feedback_1_1ASIFilter.html">smooth::feedback::ASIFilter&lt;T, X&lt;double&gt;</a>, U&lt;double&gt;, decltype(Sigma)&gt; asif(Sigma);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// safety set S(t) = { x : h(t, x) &gt;= 0 }</span></div>
<div class="line"><span class="keyword">auto</span> h = []&lt;<span class="keyword">typename</span> S&gt;(S, <span class="keyword">const</span> X&lt;S&gt; &amp; x) -&gt; Eigen::Matrix&lt;S, 1, 1&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> Eigen::Matrix&lt;S, 1, 1&gt;(x.template part&lt;0&gt;().r2().x() - S(0.2));</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// backup controller</span></div>
<div class="line"><span class="keyword">auto</span> bu = []&lt;<span class="keyword">typename</span> S&gt;(S, <span class="keyword">const</span> X&lt;S&gt; &amp;) -&gt; U&lt;S&gt; { <span class="keywordflow">return</span> U&lt;S&gt;(1, 1); };</div>
<div class="line"> </div>
<div class="line">T t             = T(1);</div>
<div class="line">X&lt;double&gt; x     = X&lt;double&gt;::Random();</div>
<div class="line">U&lt;double&gt; u_des = U&lt;double&gt;::Zero();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// get control input for time t, state x, and reference input u_des</span></div>
<div class="line"><span class="keyword">auto</span> [u_asif, code] = asif(t, x, u_des, h, bu);</div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1ASIFilter_html"><div class="ttname"><a href="classsmooth_1_1feedback_1_1ASIFilter.html">smooth::feedback::ASIFilter</a></div><div class="ttdoc">ASI Filter.</div><div class="ttdef"><b>Definition:</b> <a href="asif_8hpp_source.html#l00064">asif.hpp:65</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
Estimation on Lie groups</h1>
<p>Estimators take system models on the form <img src="https://latex.codecogs.com/png.image?\dpi{110}&space;\mathrm{d}^r&space;\mathbf{x}_t&space;=&space;f(t,&space;\mathbf{x}),&space;\quad&space;\mathbf{x}&space;\in&space;\mathbb{X}" alt="" class="inline"/> where <code>X</code> is a <code>smooth::LieGroup</code>, and measurements on the form <img src="https://latex.codecogs.com/png.image?\dpi{110}&space;\mathbf{y}&space;=&space;h(\mathbf{x})&space;\oplus_r&space;w,&space;\;&space;w&space;\in&space;\mathcal&space;N(0,&space;R)" alt="" class="inline"/>.</p>
<p>To use in a feedback loop for a controlled system use partial application: </p><div class="fragment"><div class="line"><span class="comment">// variable that holds current input</span></div>
<div class="line">U&lt;double&gt; u = U&lt;double&gt;::Random();</div>
<div class="line"><span class="comment">// closed-loop dynamics (time type must be Scalar&lt;X&gt;)</span></div>
<div class="line"><span class="keyword">auto</span> SigmaCL = [&amp;u]&lt;<span class="keyword">typename</span> S&gt;(<span class="keywordtype">double</span> t, <span class="keyword">const</span> X&lt;S&gt; &amp; x) -&gt; smooth::Tangent&lt;X&lt;S&gt;&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> Sigma(T(t), x, u.template cast&lt;S&gt;());</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Extended Kalman Filter</h2>
<ul>
<li>Templated over dynamics and measurement models</li>
<li>Automatic differentiation</li>
<li>Reduces to <a href="https://en.wikipedia.org/wiki/Kalman_filter">standard Kalman filter (KF)</a> for linear models on Rn</li>
<li>Reduces to <a href="https://en.wikipedia.org/wiki/Invariant_extended_Kalman_filter">Invariant Extended Kalman Filter (IEKF)</a> for group-linear models on Lie groups</li>
</ul>
<p><b>Example: localization with a known 2D landmark</b> for the system <code>SigmaCL</code></p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;smooth/feedback/ekf.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// create filter</span></div>
<div class="line"><a class="code" href="classsmooth_1_1feedback_1_1EKF.html">smooth::feedback::EKF&lt;X&lt;double&gt;</a>&gt; ekf;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// measurement model</span></div>
<div class="line">Eigen::Vector2d landmark(1, 1);</div>
<div class="line"><span class="keyword">auto</span> h = [&amp;landmark]&lt;<span class="keyword">typename</span> S&gt;(<span class="keyword">const</span> X&lt;S&gt; &amp; x) -&gt; Eigen::Matrix&lt;S, 2, 1&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> x.template part&lt;0&gt;().inverse() * landmark;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// PREDICT STEP: propagate filter over time</span></div>
<div class="line">ekf.<a class="code" href="classsmooth_1_1feedback_1_1EKF.html#a9d57cbe2f7594295531de756ab98e85d">predict</a>(SigmaCL,</div>
<div class="line">  Eigen::Matrix&lt;double, 6, 6&gt;::Identity(),  <span class="comment">// motion covariance Q</span></div>
<div class="line">  1.                                        <span class="comment">// time step length</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// UPDATE STEP: register a measurement of the known landmark</span></div>
<div class="line">ekf.<a class="code" href="classsmooth_1_1feedback_1_1EKF.html#a57a23546447c59ae8dbfc4cacf23636e">update</a>(h,</div>
<div class="line">  Eigen::Vector2d(0.3, 0.6),   <span class="comment">// measurement result y</span></div>
<div class="line">  Eigen::Matrix2d::Identity()  <span class="comment">// measurement covariance R</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// access estimate</span></div>
<div class="line"><span class="keyword">auto</span> x_hat = ekf.<a class="code" href="classsmooth_1_1feedback_1_1EKF.html#a9195311596dd7eb2d0cbcc9dff2f7ca3">estimate</a>();</div>
<div class="line"><span class="keyword">auto</span> P_hat = ekf.<a class="code" href="classsmooth_1_1feedback_1_1EKF.html#abc62dc4780a5e8a9e96e7bbfa9f29338">covariance</a>();</div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1EKF_html"><div class="ttname"><a href="classsmooth_1_1feedback_1_1EKF.html">smooth::feedback::EKF</a></div><div class="ttdoc">Extended Kalman filter on Lie groups.</div><div class="ttdef"><b>Definition:</b> <a href="ekf_8hpp_source.html#l00054">ekf.hpp:55</a></div></div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1EKF_html_a57a23546447c59ae8dbfc4cacf23636e"><div class="ttname"><a href="classsmooth_1_1feedback_1_1EKF.html#a57a23546447c59ae8dbfc4cacf23636e">smooth::feedback::EKF::update</a></div><div class="ttdeci">void update(F &amp;&amp;h, const Y &amp;y, const Eigen::MatrixBase&lt; RDev &gt; &amp;R)</div><div class="ttdoc">Update EKF with a measurement  where .</div><div class="ttdef"><b>Definition:</b> <a href="ekf_8hpp_source.html#l00143">ekf.hpp:143</a></div></div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1EKF_html_a9195311596dd7eb2d0cbcc9dff2f7ca3"><div class="ttname"><a href="classsmooth_1_1feedback_1_1EKF.html#a9195311596dd7eb2d0cbcc9dff2f7ca3">smooth::feedback::EKF::estimate</a></div><div class="ttdeci">G estimate() const</div><div class="ttdoc">Access filter state estimate.</div><div class="ttdef"><b>Definition:</b> <a href="ekf_8hpp_source.html#l00078">ekf.hpp:78</a></div></div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1EKF_html_a9d57cbe2f7594295531de756ab98e85d"><div class="ttname"><a href="classsmooth_1_1feedback_1_1EKF.html#a9d57cbe2f7594295531de756ab98e85d">smooth::feedback::EKF::predict</a></div><div class="ttdeci">void predict(F &amp;&amp;f, const Eigen::MatrixBase&lt; QDer &gt; &amp;Q, Scalar&lt; G &gt; tau, std::optional&lt; Scalar&lt; G &gt;&gt; dt={})</div><div class="ttdoc">Propagate EKF through dynamics  with covariance  over a time interval .</div><div class="ttdef"><b>Definition:</b> <a href="ekf_8hpp_source.html#l00104">ekf.hpp:104</a></div></div>
<div class="ttc" id="aclasssmooth_1_1feedback_1_1EKF_html_abc62dc4780a5e8a9e96e7bbfa9f29338"><div class="ttname"><a href="classsmooth_1_1feedback_1_1EKF.html#abc62dc4780a5e8a9e96e7bbfa9f29338">smooth::feedback::EKF::covariance</a></div><div class="ttdeci">CovT covariance() const</div><div class="ttdoc">Access filter covariance.</div><div class="ttdef"><b>Definition:</b> <a href="ekf_8hpp_source.html#l00083">ekf.hpp:83</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7"></a>
Optimization</h1>
<p>MPC and ASIF relies on online quadratic program optimization.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Fast QP Solver</h2>
<ul>
<li>Eigen-native port of the <a href="https://osqp.org/">operator splitting QP solver</a>.</li>
<li>Solves both dense and sparse problems.</li>
<li>Eigen lazy evaluations enable fast SIMD in the compiled assembly.</li>
</ul>
<p>The plot below compares solution times (lower is better) for random square QPs over three different levels of sparsity. The results suggest that the dense solver is the best choice except for problems that are both large and very sparse. Performance is however highly problem-dependent and should ideally be evaluated on a per-application basis.</p>
<p><img src="media/qp_benchmarks.png" alt="" width="100%" class="inline"/></p>
<p>The results are generated from the benchmarking program in <code>benchmark/</code>.</p>
<p><b>Example</b>: Define and solve a dynamically sized dense quadratic program.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="qp_8hpp.html">smooth/feedback/qp.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// define the QP</span></div>
<div class="line"><span class="comment">//  min 0.5 x&#39; * P * x + q&#39; * x</span></div>
<div class="line"><span class="comment">//  s.t l &lt;= A * x &lt;= u</span></div>
<div class="line"><a class="code" href="structsmooth_1_1feedback_1_1QuadraticProgram.html">smooth::feedback::QuadraticProgram</a>&lt;-1, -1&gt; qp{</div>
<div class="line">  .<a class="code" href="structsmooth_1_1feedback_1_1QuadraticProgram.html#a0f23929c20ff8fd2c8ee6ca09b057e13">P</a> = P,  <span class="comment">// n x n matrix</span></div>
<div class="line">  .q = q,  <span class="comment">// n x 1 vector</span></div>
<div class="line">  .A = A,  <span class="comment">// m x n matrix</span></div>
<div class="line">  .l = l,  <span class="comment">// m x 1 vector</span></div>
<div class="line">  .u = u,  <span class="comment">// m x 1 vector</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structsmooth_1_1feedback_1_1QPSolverParams.html">smooth::feedback::QPSolverParams</a> prm{};</div>
<div class="line"><span class="keyword">auto</span> sol = <a class="code" href="qp_8hpp.html#a2151e5a179ada80d491aaaa0e0e88479">smooth::feedback::solve_qp</a>(qp, prm);</div>
<div class="ttc" id="aqp_8hpp_html"><div class="ttname"><a href="qp_8hpp.html">qp.hpp</a></div><div class="ttdoc">Quadratic Programming.</div></div>
<div class="ttc" id="aqp_8hpp_html_a2151e5a179ada80d491aaaa0e0e88479"><div class="ttname"><a href="qp_8hpp.html#a2151e5a179ada80d491aaaa0e0e88479">smooth::feedback::solve_qp</a></div><div class="ttdeci">detail::qp_solution_t&lt; Pbm &gt; solve_qp(const Pbm &amp;pbm, const QPSolverParams &amp;prm, std::optional&lt; std::reference_wrapper&lt; const detail::qp_solution_t&lt; Pbm &gt;&gt;&gt; warmstart={})</div><div class="ttdoc">Solve a quadratic program using the operator splitting approach.</div><div class="ttdef"><b>Definition:</b> <a href="qp_8hpp_source.html#l00574">qp.hpp:574</a></div></div>
<div class="ttc" id="astructsmooth_1_1feedback_1_1QPSolverParams_html"><div class="ttname"><a href="structsmooth_1_1feedback_1_1QPSolverParams.html">smooth::feedback::QPSolverParams</a></div><div class="ttdoc">Options for solve_qp.</div><div class="ttdef"><b>Definition:</b> <a href="qp_8hpp_source.html#l00143">qp.hpp:144</a></div></div>
<div class="ttc" id="astructsmooth_1_1feedback_1_1QuadraticProgram_html"><div class="ttname"><a href="structsmooth_1_1feedback_1_1QuadraticProgram.html">smooth::feedback::QuadraticProgram</a></div><div class="ttdoc">Quadratic program definition.</div><div class="ttdef"><b>Definition:</b> <a href="qp_8hpp_source.html#l00063">qp.hpp:64</a></div></div>
<div class="ttc" id="astructsmooth_1_1feedback_1_1QuadraticProgram_html_a0f23929c20ff8fd2c8ee6ca09b057e13"><div class="ttname"><a href="structsmooth_1_1feedback_1_1QuadraticProgram.html#a0f23929c20ff8fd2c8ee6ca09b057e13">smooth::feedback::QuadraticProgram::P</a></div><div class="ttdeci">Eigen::Matrix&lt; Scalar, N, N &gt; P</div><div class="ttdoc">Positive semi-definite square cost (only upper trianglular part is used)</div><div class="ttdef"><b>Definition:</b> <a href="qp_8hpp_source.html#l00066">qp.hpp:66</a></div></div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
